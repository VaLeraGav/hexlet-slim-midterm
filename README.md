## 2. Архитектура Веба
Принцип взаимодействия с любым сайтом сводится к следующим шагам (сам процесс сложнее, но нас интересует только взаимодействие с приложением):

1. Пользователь запрашивает страницу сайта
2. Браузер выполняет HTTP-запрос к веб-серверу
3. Веб-сервер возвращает содержимое страницы в HTTP-ответе
4. Браузер отрисовывает страницу сайта
5. Пользователь кликает по ссылке на сайте и весь процесс повторяется снова.

В конечном итоге, код сайта представляет из себя набор обработчиков разных страниц, которые принимают входящие запросы, формируют ответ и возвращают его. 

## 3. Веб-сервер

Браузер, благодаря DNS, получает IP-адрес компьютера, на котором расположен сайт указанного домена (например, google.com). А вот откуда он знает порт, на котором висит веб-сервер в ожидании входящих запросов? Ответ на этот вопрос очень простой: существует соглашение, согласно которому веб-сервер, обслуживающий сайт по протоколу HTTP, слушает порт `80`, а протокол HTTPS обслуживается на порту `443`. Но так бывает не всегда. Во время локальной разработки обычно используются другие порты, например, `3000`, или `4000`. Сам номер не принципиален, главное, что он доступен для веб-сервера, и вы обращаетесь через браузер именно к нему. Порт указывается через двоеточие после названия сайта, например `www.google.com:80`.

`Веб-сервер` — специализированная программа для обслуживания сайтов. Один веб-сервер может обрабатывать практически любое число сайтов (Virtual Hosts в HTTP). В общем случае он перенаправляет входящие сетевые запросы на код сайтов, получает от них ответ и возвращает его браузеру.

Первым и самым простым способом взаимодействия веб-сервера с сайтом был CGI (Common Gateway Interface). Этот стандарт сразу разрабатывался с учётом того, что сервер не должен зависеть от того, на чём написан сайт. Он основан на переменных окружения. По сути, сайт представляет из себя исполняемый файл, который запускается веб-сервером во время обработки входящего запроса и передаёт в него все параметры запроса через переменные окружения. Всё, что требуется от скрипта, — это вернуть HTTP-ответ в стандартный вывод (STDOUT). Общий алгоритм работы выглядит так:

1. Клиент запрашивает страницу сайта.
2. Веб-сервер принимает запрос и устанавливает переменные окружения (через них приложению передаются данные и служебная информация).
3. Веб-сервер перенаправляет запросы через стандартный поток ввода (stdin) на вход вызываемой программы.
4. CGI-приложение выполняет все необходимые операции и формирует результаты в виде HTML.
5. Сформированный гипертекст возвращается веб-серверу через стандартный поток вывода (stdout). Сообщения об ошибках передаются через поток ошибок (stderr).
6. Веб-сервер передаёт результаты запроса клиенту.


![Common Gateway Interface](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImU3NzliMzcxYjM2ZmY5NWE1YjZjOGY2YzE2NDVmYzI4LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=20b749088ec3c5136175aa59b39dc226b33d349e77a5a3576e04198d54f28325)

Очень важно осознать, что в режиме CGI, скрипт, который представляет из себя сайт (как программу), запускается на каждый запрос заново. Это значит, что вся логика инициализации отрабатывает для каждого запроса по новой, а после выполнения запроса, ничего не остаётся (скрипт просто завершается). Если между запросами есть некоторое состояние (например, пользователь что-то сохранил), то его нужно отправлять в какое-то хранилище, файловую систему (создать файл) или базу данных.

## 4. Встроенный в PHP веб-сервер

```
php -S localhost:8080
```
Посмотреть какой процесс занял порт 8080 можно командой 
```
sudo lsof -i :8080
```
После этого откройте браузер и введите `http://localhost:8080`. На экран выведется текущий год. В терминале, где запущен веб-сервер, появятся записи (лог), показывающие входящие запросы.
```
[Wed May 27 14:53:31 2020] [::1]:52988 [200]: GET /
[Wed May 27 14:53:31 2020] [::1]:52990 [404]: GET /favicon.ico - No such file or directory
```

## 5. PHP CGI

curl используется для передачи любых данных и ряда других полезных задач -v максимально подробный вывод. ( GET -  запрос )
```
curl -v localhost:8080
```
```
curl --head localhost:8080

HTTP/1.1 200 OK
Host: localhost:8080
Date: Wed, 27 May 2020 12:17:57 GMT
Connection: close
X-Powered-By: PHP/7.4.3
Cache-control: private, max-age=0
Content-type: text/html; charset=UTF-8
```
Заголовок, установленный с помощью функции header() появился в ответе. Помните, что функцию header() можно вызывать только если клиенту ещё не передавались данные. То есть она должна идти в коде первой до любого вывода. Это требование вытекает из устройства HTTP. Сначала идут заголовки и только потом тело.

Массив $_SERVER содержит в себе все заголовки запроса:
```
Array
(
    [DOCUMENT_ROOT] => /private/tmp
    [REMOTE_ADDR] => ::1
    [REMOTE_PORT] => 58667
    [SERVER_SOFTWARE] => PHP 7.4.3 Development Server
    [SERVER_PROTOCOL] => HTTP/1.1
    [SERVER_NAME] => localhost
    [SERVER_PORT] => 8080
    [REQUEST_URI] => /
    [REQUEST_METHOD] => GET
    [SCRIPT_NAME] => /index.php
    [SCRIPT_FILENAME] => /private/tmp/index.php
    [PHP_SELF] => /index.php
    [HTTP_HOST] => localhost:8080
    [HTTP_USER_AGENT] => curl/7.68.0
    [HTTP_ACCEPT] => */*
    [REQUEST_TIME_FLOAT] => 1530772973.7628
    [REQUEST_TIME] => 1530772973
)
```

## 6. HTML в PHP

Любой PHP файл, на самом деле – обычный текстовый файл со вставками PHP кода (с помощью тегов <?php ?>). Любой текст написанный внутри него, отдается в вывод как есть, будь то браузер или запуск в командной строке.

```php
вместо <?php echo ... используется <?= ....
```

## 7. Микрофреймворк Slim

Веб-фреймворки подразделяются на две большие группы, одна из которых так и называется — фреймворки, а другая — микрофреймворки. Микрофреймворки устроены значительно проще и содержат внутри себя только минимально необходимую обвязку для комфортной работы в архитектуре HTTP — запрос-ответ.
```json
{
    "require": {
        "slim/slim": "^4.9",
        "slim/psr7": "^1.5",
        "slim/http": "^1.2",
        "slim/php-view": "^3.1",
        "php-di/php-di": "^6.3"
    }
}
```

## 8. Обработчики запросов
```php
$app = AppFactory::create();

$app->get('/', function ($request, $response) {
    return $response->write('Welcome to Slim!');
});
```

Общий принцип работы любого веб-фреймворка отражает архитектуру HTTP. На каждый адрес задаётся обработчик (функция, handler), который выполняет необходимые действия и возвращает ответ. В Slim, все приложение (сайт) представлено объектом класса Slim\App. Этот объект содержит методы на каждый глагол HTTP: `get`, `post`, `put` и так далее. Эти методы принимают на вход два параметра, первый — адрес (говорят «маршрут»), для которого вызовется обработчик и второй, собственно сам обработчик. Лямбда-функция с двумя параметрами `$request` и `$response`.

Во фреймворках принято (и это соответствует идеям REST) определять маршрут, как комбинацию метода HTTP и адреса. То есть GET /users и POST /users с точки зрения большинства фреймворков — разные маршруты со своими обработчиками.

```php
$app = AppFactory::create();

$app->get('/users', function ($request, $response) {
    return $response->write('GET /users');
});

$app->post('/users', function ($request, $response) {
    return $response->write('POST /users');
});

$app->run();
```
```
curl localhost:8080/users

GET /users
```
```
curl -XPOST localhost:8080/users

POST /users
```
Интересный вопрос заключается в том, что произойдёт, если фреймворк не обнаружит соответствия? Например, клиент запросит страницу /comments? В такой ситуации, фреймворк берёт управление на себя (по умолчанию) и автоматически отдаёт браузеру ответ 404, то есть говорит о том что страница не найдена.

## 9. HTTP Сессия (запрос и ответ)

Каждая HTTP-сессия определяется двумя вещами - запросом и ответом. Запрос формируется клиентом, например браузером, а ответ - сервером. 
```php
$app->get('/', function ($request, $response) {
    $response->getBody()->write('Hello, world!');
    return $response;
});
```
`$request` используется для извлечения данных запроса, например, заголовков или содержимого отправленной формы. У запроса нет сеттеров. Его уже выполнили и он не может поменяться.
```php
// Возвращает все заголовки
$request->getHeaders();
```
В противоположность этому, `$response` используется для формирования ответа и в процессе работы "наполняется" данными: заголовками и телом.
```php
// Устанавливает код ответа
$response->withStatus(204);

$response->getBody()->write('<a href="/hello/world">Try /hello/world</a>');
```
Тело ответа хранится внутри `$response` как объект, который можно получить через метод `getBody()`. А метод `write()` записывает данные в этот объект. Такая структура объектов выбрана не просто так, HTTP позволяет отдавать данные потоком (чанками), для которых нужны свои особенные методы работы.

Несмотря на то что объект с телом ответа может меняться, сам `$response` никогда не изменяется. Любой его метод формирует новый $response:
```php
$app->get('/', function ($request, $response) {
    // Возвращается новый объект
    $response2 = $response->withStatus(204);
    return $response2;
});
```
```php
$app->get('/companies', function ($request, $response) use ($companies) {
    $page = $request->getQueryParam('page', 1);
    $per = $request->getQueryParam('per', 5);
    
    $offset = ($page - 1) * $per;
    $result = array_slice($companies, $offset, $per);
    // упрощающий процесс возврата данных JSON
    return $response->withJson($result);
});
```
## 10. Динамические маршруты

Любая изменяемая часть маршрута называется плейсхолдером (заполнитель). В маршруте выше только один плейсхолдер `id`. Доступ к значению конкретного плейсхолдера осуществляется по имени через массив `$args`, передающийся третьим параметром в функцию-обработчик.

Подведем промежуточный итог. Понятия адрес и маршрут обозначают разные вещи. Если маршрут статический, то он всегда совпадает с адресом, например, `/about`. Если маршрут динамический, то ему могут соответствовать бесконечное число адресов (даже если таких страниц на сайте нет), например, `/courses/:id`.

```php
$app->get('/courses/{courseId}/lessons/{id}', function ($request, $response, array $args) {
    $courseId = $args['courseId'];
    $id = $args['id'];
    return $response->write("Course id: {$courseId}")
      ->write("Lesson id: {$id}");
});
```

## 11. Шаблонизатор

Измените настройку Slim в начале файла `public/index.php` так как показано в примере:

```php
require_once dirname(__DIR__) . "/../../vendor/autoload.php";
// Контейнеры в этом курсе не рассматриваются (это тема связанная с самим ООП), но если вам интересно, то посмотрите DI Container
use Slim\Factory\AppFactory;
use DI\Container;

$container = new Container();
$container->set('renderer', function () {
    // Параметром передается базовая директория, в которой будут храниться шаблоны
    return new \Slim\Views\PhpRenderer(__DIR__ . '/../templates');
});
$app = AppFactory::createFromContainer($container);
$app->addErrorMiddleware(true, true, true);

$app->get('/users/{id}', function ($request, $response, $args) {
    $params = ['id' => $args['id'], 'nickname' => 'user-' . $args['id']];
    // Указанный путь считается относительно базовой директории для шаблонов, заданной на этапе конфигурации
    // $this доступен внутри анонимной функции благодаря https://php.net/manual/ru/closure.bindto.php
    // $this в Slim это контейнер зависимостей
    return $this->get('renderer')->render($response, 'users/show.phtml', $params);
});

// templates/users/show.phtml
<h1>Hello, <?= $id ?></h1>
```
В этих строчках происходит подключение шаблонизатора к Слиму, используя DI Container. Наши шаблоны будут храниться в директории templates в корне проекта.

Метод `render()` выполняет рендеринг указанного шаблона и добавляет результат в ответ. Сама функция принимает на вход три параметра:
 - Объект ответа
 - Путь до нужного шаблона внутри директории `templates`
 - Набор параметров, которые будут доступны внутри шаблона. Сюда можно передавать все, что угодно.
 
Расширение `phtml` используют тогда, когда хотят показать что внутри файла содержится шаблон на PHP, в остальном файл рассматривается как обычный файл с кодом на PHP.

## 12. Безопасность

>Главное правило безопасности звучит так: "Никогда не доверяйте пользователям". 

```php
// Вот, что может произойти, если доверять данным,
// которые ввёл пользователь, и не обрабатывать их. Банер выскочил 
http://localhost:8080/users/%3Cscript%3Ealert('attack!')%3B%3C%2Fscript%3E

// ERROR: Slim\Exception\HttpNotFoundException
```
Такая атака называется XSS или Межсайтовый скриптинг. Она работает так: на страницу внедряется вредоносный код, который выполняется в браузере пользователя и отправляет информацию о пользователе на сервер злоумышленника. 

Для вывода данных, которые не рассматриваются как HTML, обязательно использовать специализированные функции превращающие теги в html entities.
```html
<h1><?= htmlspecialchars($id) ?></h1>
```

## 13. Поисковые формы

Основной элемент формы тег `<form>`. Все элементы формы должны быть вложены в него. У этого тега есть атрибут action, в котором можно указать адрес на который отправятся данные формы (по умолчанию будет использован адрес текущей страницы). Второй часто используемый атрибут - `method`. Он принимает два возможных параметра `get` или `post`, что соответствует HTTP методам.

Для элементов формы используются теги `input`, `button`, `select` и `textarea`.

В свою очередь тег `<input>` благодаря атрибуту type может принимать множество различных форм:

- Множественный выбор (`checkbox`)
- Одиночный выбор (`radio`)
- Кнопка отправки формы (`submit`)
- Поле для ввода пароля (`password`)
- Множество других таких как: tel, email, range и т.п.

К общим атрибутам относится атрибут `required`. Его наличие включает проверку обязательности заполнения на клиенте (в браузере). Попытка отправить форму с незаполненными элементами, помеченными этим атрибутом, приведет к показу сообщения о том что требуется заполнение. 

## 14. Персистентность

>персистентность — возможность долговременного хранения состояния

Для постоянного (персистентного) хранения данных принято использовать специализированные программы — базы данных. Взаимодействие с ними строят двумя способами. Либо работая напрямую через библиотеку, предназначенную для данной базы данных. Либо через `ORM`, которая в большинстве случаев прячет базу данных за горой абстракций.

```php
// Doctrine ORM
$user = new User();
$user->setName($newUsername);

$entityManager->persist($user);
$entityManager->flush();
```

## 15. Модифицирующие формы

Начнём с того, что за вывод формы и её обработку должны отвечать два разных обработчика (а значит это разные маршруты). Ниже пример маршрутов для создания нового пользователя:

- GET /users/new — страница с формой, которую заполняет пользователь. Эта форма отправляет POST-запрос на адрес /users, указанный в атрибуте action.
- POST /users — маршрут, обрабатывающий данные формы

Я выбрал именно такие маршруты не случайно. Подобная схема именования рекомендуется и автоматически создаётся многими фреймворками, такими как Rails. Она хорошо ложится на REST-архитектуру, о которой мы ещё поговорим.

```html
<!-- templates/users/new.phtml -->
<form action="/users" method="post">
  <div>
    <label>
        Имя
      <input type="text" name="user[name]">
    </label>
  </div>
  <div>
    <label>
      Email
      <input type="email" required name="user[email]">
    </label>
    </div>
  <div>
<!-- ... -->
```
Интересный момент в форме выше, то как задаются имена. Каждое имя определяется как ключ в массиве `user`. Такой способ определения имён не является обязательным, но он очень удобен для массовой обработки значений формы. Их изоляция в одном массиве позволяет избежать потенциальных пересечений с другими данными. В поисковых формах эта схема тоже удобна, если количество элементов больше одного.

```php
$repo = new App\UserRepository();

$app->post('/users', function ($request, $response) use ($repo) {
    $validator = new Validator();
    $user = $request->getParsedBodyParam('user');
    $errors = $validator->validate($user);
    if (count($errors) === 0) {
        $repo->save($user);
        return $response->withRedirect('/users', 302);
    }
    $params = [
        'user' => $user,
        'errors' => $errors
    ];
    return $this->get('renderer')->render($response, "users/new.phtml", $params);
});
```
Разберем программу по частям:
1.  В нашем случае валидация реализуется классом с одним методом `validate()`, который проверяет данные формы и возвращает специальный массив `$errors`, в котором ключ — это название поля, а значение — текст ошибки, который нужно вывести в форме.
```php
$validator = new Validator();

// function validate($user)
// {
//     $errors = [];
//     if (empty($user['name'])) {
//         $errors['name'] = "Can't be blank"
//     }
//     // ...
//     return $errors;
// }
$errors = $validator->validate($user);
```
2. Если ошибок нет, то данные формы сохраняются, например, в базу данных.
```php
if (count($errors) === 0) {
    $repo->save($user);
    return $response->withRedirect('/users');
}
```
3.  Если попробовать в этот момент нажать `f5`, то браузер выдаст предупреждение о том, что вы пытаетесь повторно отправить данные. Это сообщение предупреждает о том, что метод `POST` не идемпотентен, и повторная отправка формы может привести к повторному созданию пользователя. Отпарвка переменных в форму:
```php
$params = [
    'user' => $user,
    'errors' => $errors
];
return $this->get('renderer')->render($response, "users/new.phtml", $params);
```
Теперь давайте вернёмся к нашей форме и изменим её так, чтобы в неё подставлялись как возникающие ошибки, так и значения полей, введённые пользователем.
```html
<!-- templates/users/new.phtml -->
<form action="/users" method="post">
  <div>
    <label>
        Имя
      <input type="text" name="user[name]" value="<?= htmlspecialchars($user['name']) ?>">
    </label>
    <?php if (isset($errors['name'])): ?>
      <div><?= $errors['name'] ?></div>
    <?php endif ?>
  </div>
  <div>
    <label>
        Email
      <input type="email" required name="user[email]" value="<?= htmlspecialchars($user['email']) ?>">
    </label>
    <?php if (isset($errors['email'])): ?>
      <div><?= $errors['email'] ?></div>
    <?php endif ?>
  </div>
  <!-- ... -->
  <div>
    <label>
        Подтверждение пароля
      <input type="password" required name="user[passwordConfirmation]" value="<?= htmlspecialchars($user['passwordConfirmation']) ?>">
    </label>
  </div>
  <div>
    <label>
      Город
      <select name="user[city]">
        <option value="">Select</option>
        <option <?= $user['city'] === '3' ? 'selected' : '' ?> value="3">Москва</option>
        <option <?= $user['city'] === '13' ? 'selected' : '' ?> value="13">Пенза</option>
        <option <?= $user['city'] === '399' ? 'selected' : '' ?> value="399">Томск</option>
      </select>
    </label>
    <?php if (isset($errors['city'])): ?>
      <div><?= $errors['city'] ?></div>
    <?php endif ?>
  </div>
  <input type="submit" value="Sign Up">
</form>
```
В свою очередь такое изменение формы требует изменения обработчика /users/new. Во избежание ошибок необходимо передать в шаблон пустой массив $errors и массив $user, в котором необходимо задать значения по умолчанию для соответствующих полей формы. Таким образом в шаблоне не придётся выполнять проверку данных формы на существование.

```php
$app->get('/users/new', function ($request, $response) {
    $params = [
        'user' => ['name' => '', 'email' => '', 'password' => '', 'passwordConfirmation' => '', 'city' => ''],
        'errors' => []
    ];
    return $this->get('renderer')->render($response, "users/new.phtml", $params);
});
```
Для генерации форм используются специальные билдеры.


## 16. Именованные маршруты

## 17. Стандарт PSR7

## 18. Flash

## 19. CRUD

## 20. CRUD: Создание

## 21. CRUD: Обновление

## 22. CRUD: Удаление

## 23. Model-View-Controller (MVC)

## 24. Cookies

## 25. Сессия

## 26. Деплой